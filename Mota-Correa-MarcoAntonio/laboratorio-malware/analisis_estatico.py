import sys
import json
import time
import docker
import requests
import os
import tarfile
import time
from io import BytesIO

def generate_tar_stream(local_path):
	"""Abrir Stream para tranferencia de archivo hacia la API docker."""
	tarstream = BytesIO()
	with open(local_path, 'rb') as file_data:
		data = file_data.read()
		tar = tarfile.TarFile(fileobj=tarstream, mode='w')
		tarinfo = tarfile.TarInfo(name=f"{os.path.basename(local_path).split(os.sep)[-1]}")
		tarinfo.size = len(data)
		tarinfo.mtime = time.time()
		tar.addfile(tarinfo, BytesIO(data))
		tar.close()
	tarstream.seek(0)
	return tarstream

def generate_tar_stream_result(file,file_name):
	"""Abrir Stream para tranferencia de un archivo dentro de la API docker."""
	tarstream = BytesIO()
	data = file.encode("UTF-8")
	tar = tarfile.TarFile(fileobj=tarstream, mode='w')
	tarinfo = tarfile.TarInfo(name=file_name)
	tarinfo.size = len(data)
	tarinfo.mtime = time.time()
	tar.addfile(tarinfo, BytesIO(data))
	tar.close()
	tarstream.seek(0)
	return tarstream

def load_json_file(file_path):
	"""Carga datos de un archivo JSON."""
	try:
		with open(file_path, 'r') as file:
			return json.load(file)
	except FileNotFoundError:
		print(f"Error: No se encontró el archivo {file_path}")
		sys.exit(1)
	except json.JSONDecodeError:
		print(f"Error al decodificar JSON en el archivo {file_path}")
		sys.exit(1)

def download_files_from_api(save_path, downloads):
	"""Descarga múltiples archivos desde una API."""
	local_paths = []
	for item in downloads:
		url = f"{item['path']}"
		output = save_path+os.sep+item.get("save_as")

		print(f"Descargando desde {url}...")
		try:
			response = requests.get(url, stream=True)
			if response.status_code == 200:
				with open(output, "wb") as file:
					for chunk in response.iter_content(chunk_size=8192):
						file.write(chunk)
				print(f"Archivo descargado: {item.get("save_as")}")
				local_paths.append(output)
			else:
				print(f"Error al descargar {url}. Código de estado: {response.status_code}")
		except Exception as e:
			print(f"Error descargando desde {url}: {e}")
	return local_paths

def get_or_create_container(client, image_name, container_name="malware-lab"):
	"""Obtiene un contenedor existente o crea uno nuevo."""
	try:
		container = client.containers.get(container_name)
		print(f"Reutilizando el contenedor existente '{container_name}'")

		# Verifica si el contenedor está corriendo
		if container.status != 'running':
			print(f"El contenedor '{container_name}' no está corriendo. Iniciándolo...")
			container.start()
	except docker.errors.NotFound:
		print(f"No se encontró el contenedor '{container_name}', creando uno nuevo.")
		container = client.containers.run(image_name, name=container_name, detach=True, tty=True)

	return container


def execute_commands_in_docker(config,downloaded_files,local_files):
	"""Reutiliza o crea un contenedor Docker y ejecuta comandos en él."""
	client = docker.from_env()
	try:
		container = get_or_create_container(client, config["image_name"], config["container_name"])

		# Instalar herramientas necesarias en el contenedor
		install_commands = [#binutils ssdeep file exiftool radare2
			"apt-get update",
			"apt-get -y -force=yes install coreutils",
			"apt-get -y -force=yes install binutils",
			"apt-get -y -force=yes install ssdeep",
			"apt-get -y -force=yes install file",
			"apt-get -y -force=yes install exiftool",
			"apt-get -y -force=yes install radare2",
			"apt-get -y -force=yes install nano"
		]
		print("Instalando herramientas en el contenedor si es necesario...")
		for cmd in install_commands:
			exit_code, output = container.exec_run(cmd)
			print(output.decode())

		print("Comenzando experimentos...")
		container.exec_run(f"mkdir /tmp/{config.get("experiment-name")}-results")
		# Transferir los archivos descargados y locales al contenedor
		for path in downloaded_files:
			file_name = f"{os.path.basename(path).split(os.sep)[-1]}"
			container.exec_run(f"mkdir /tmp/{config.get("experiment-name")}-results/{file_name}-ouputs")
			remote_path = f"/tmp/{config.get("experiment-name")}-samples"
			container.exec_run(f"mkdir {remote_path}")
			print(f"Tranferiendo archivo {path} al contenedor en {remote_path}...")
			container.put_archive(remote_path, generate_tar_stream(path))
			print(f"Archivo {path} transferido al contenedor en {remote_path}")

			# Ejecutar los comandos para cada archivo
			for command in config["commands"]:
				try:
					container.put_archive(f"/tmp/{config.get("experiment-name")}-results/{file_name}-ouputs",generate_tar_stream_result(execute_command(container,command,remote_path+"/"+file_name),f"{file_name}-{command}.txt"))
				except Exception as e:
					print(f"Algo salio mal... {e}")

		for path in local_files:
			file_name = f"{os.path.basename(path).split(os.sep)[-1]}"
			container.exec_run(f"mkdir /tmp/{config.get("experiment-name")}-results/{file_name}-ouputs")
			remote_path = f"/tmp/{config.get("experiment-name")}-samples"
			container.exec_run(f"mkdir {remote_path}")
			print(f"Tranferiendo archivo {path} al contenedor en {remote_path}...")
			container.put_archive(remote_path, generate_tar_stream(path))
			print(f"Archivo {path} transferido al contenedor en {remote_path}")

			for command in config["commands"]:
				try:
					container.put_archive(f"/tmp/{config.get("experiment-name")}-results/{file_name}-ouputs",generate_tar_stream_result(execute_command(container,command,remote_path+"/"+file_name),f"{file_name}-{command}.txt"))
				except Exception as e:
					print(f"Algo salio mal... {e}")
				
	except Exception as e:
		print(f"Error: {e}")
	finally:
		print("La ejecución ha terminado. El contenedor sigue activo para futuras ejecuciones.")

def execute_command(container,command,file_path):
	# Arbol de ejecuciones
	file = ""
	match command:
		case "md5sum":
			return simple_exec(container,command,file_path)
		case "sha1sum":
			return simple_exec(container,command,file_path)
		case "sha256sum":
			return simple_exec(container,command,file_path)
		case "file":
			return simple_exec(container,command,file_path)
		case "exiftool":
			return simple_exec(container,command,file_path)
		case "strings":
			full_command = f"{command} {file_path}"
			print(f"Ejecutando el comando: {full_command} en el contenedor")
			exit_code, output = container.exec_run(full_command)
			print("Salida:")
			print(output.decode())
			return output.decode()
		case "objdump":
			file = simple_exec(container,"file",file_path)
			if "ELF" in file or "PE" in file or "MACH-O" in file:
				full_command = f"{command} -d {file_path}"
				print(f"Ejecutando el comando: {full_command} en el contenedor")
				exit_code, output = container.exec_run(full_command)
				print("Salida:")
				print(output.decode())
				return output.decode()
			else:
				print(f"El comando: {command} no se puede aplicar a este tipo de archivo")
				return "Este comando no se puede aplicar a este tipo de archivo"
		case "r2":
			file = simple_exec(container,"file",file_path)
			if "ELF" in file or "PE" in file or "MACH-O" in file:
				full_command = f"r2 -c \"aaa; pd $s > radare2.asm; q\" {file_path}"
				print(f"Ejecutando el comando: {full_command} en el contenedor")
				temp_exit_code, temp_output = container.exec_run(full_command)
				print("Salida:")
				print(temp_output.decode())
				exit_code, output = container.exec_run("cat radare2.asm")
				out = output.decode()
				container.exec_run("rm radare2.asm")
				return out
			else:
				print(f"El comando: {command} no se puede aplicar a este tipo de archivo")
				return "Este comando no se puede aplicar a este tipo de archivo"
		case "ssdeep":
			file = simple_exec(container,"file",file_path)
			if "ELF" in file or "PE" in file or "MACH-O" in file:
				full_command = f"ssdeep -b {file_path}"
				print(f"Ejecutando el comando: {full_command} en el contenedor")
				exit_code, output = container.exec_run(full_command)
				print("Salida:")
				print(output.decode())
				return output.decode()
			else:
				print(f"El comando: {command} no se puede aplicar a este tipo de archivo")
				return "Este comando no se puede aplicar a este tipo de archivo"
		case "readelf":
			file = simple_exec(container,"file",file_path)
			if "ELF" in file:
				full_command = f"{command} -e {file_path}"
				print(f"Ejecutando el comando: {full_command} en el contenedor")
				exit_code, output = container.exec_run(full_command)
				print("Salida:")
				print(output.decode())
				return output.decode()
			else:
				print(f"El comando: {command} no se puede aplicar a este tipo de archivo")
				return "Este comando no se puede aplicar a este tipo de archivo"
		case "opcodes":#r2 -c "pd > opcodes.txt" /bin/ls
			file = simple_exec(container,"file",file_path)
			if "ELF" in file or "PE" in file or "MACH-O" in file:
				full_command = f"r2 -c \"pd > opcodes.txt; q\" {file_path}"
				print(f"Ejecutando el comando: {full_command} en el contenedor")
				temp_exit_code, temp_output = container.exec_run(full_command)
				print("Salida:")
				print(temp_output.decode())
				exit_code, output = container.exec_run("cat opcodes.txt")
				out = output.decode()
				container.exec_run("rm opcodes.txt")
				return out
			else:
				print(f"El comando: {command} no se puede aplicar a este tipo de archivo")
				return "Este comando no se puede aplicar a este tipo de archivo"
			return True
		case "ldd":
			file = simple_exec(container,"file",file_path)
			if "ELF" in file or "MACH-O" in file:
				return simple_exec(container,"file",file_path)
			else:
				print(f"El comando: {command} no se puede aplicar a este tipo de archivo")
				return "Este comando no se puede aplicar a este tipo de archivo"
		case _:
			return "ERROR"
	time.sleep(5)

def simple_exec(container,command,file_path):
	# Simplificacion para un comando sin opciones
	full_command = f"{command} {file_path}"
	print(f"Ejecutando el comando: {full_command} en el contenedor")
	exit_code, output = container.exec_run(full_command)
	print("Salida:")
	print(output.decode())
	return output.decode()

def main():
	# Verificar que se hayan pasado los dos archivos JSON como argumentos
	if len(sys.argv) != 3:
		print("Uso: python programa.py archivo1.json archivo2.json")
		sys.exit(1)

	# Cargar configuración desde los JSON
	samples_file = sys.argv[1]
	config_file = sys.argv[2]
	samples = load_json_file(samples_file)
	config = load_json_file(config_file)

	#crear directorio temporal para las muestras
	exp_name = config.get("experiment-name")
	dir_path = os.getcwd()+os.sep+"samples-"+exp_name
	if not os.path.exists(dir_path):
		os.makedirs(dir_path)
	samples_path = dir_path

	# Descargar archivos desde la API
	downloaded_files = []
	if "downloads" in samples:
		downloads = samples.get("downloads", [])
		downloaded_files = download_files_from_api(samples_path,downloads)

	# Enumerar archivos locales
	local_files = []
	if "locals" in samples:
		local = samples.get("locals", [])
		for path in local:
			local_files.append(path['path'])

	if not downloaded_files and not local_files:
		print("Error: Incluya por lo menos un archivo de muestra")
		sys.exit(1)

	# Ejecutar comandos en el contenedor Docker con los archivos
	execute_commands_in_docker(config,downloaded_files,local_files)

if __name__ == "__main__":
	main()
